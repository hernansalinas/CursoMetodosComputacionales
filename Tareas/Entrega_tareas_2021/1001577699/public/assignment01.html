<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-09-29 Wed 15:37 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Assignment01</title>
<meta name="author" content="Juan David Salcedo Hernández" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/readtheorg.css"/>
<script type="text/javascript" src="src/lib/js/jquery.min.js"></script>
<script type="text/javascript" src="src/lib/js/bootstrap.min.js"></script>
<script type="text/javascript" src="src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="src/readtheorg_theme/js/readtheorg.js"></script>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Assignment01</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgae8a404">1. Plotting an electrostatic field</a></li>
<li><a href="#orgf566842">2. Projectile motion</a></li>
</ul>
</div>
</div>
<p>
In order to run this code, the following packages will be necessesary:
</p>
<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #ff79c6;">import</span> numpy <span style="color: #ff79c6;">as</span> np
<span style="color: #ff79c6;">import</span> matplotlib.pylab <span style="color: #ff79c6;">as</span> plt
</pre>
</div>

<div id="outline-container-orgae8a404" class="outline-2">
<h2 id="orgae8a404"><span class="section-number-2">1</span> Plotting an electrostatic field</h2>
<div class="outline-text-2" id="text-1">
<p>
The electrostatic field due to some point source charge \(q\) is given by Coulomb&rsquo;s law,
\[
\mathbf{E} = \frac{1}{4\pi \epsilon_0} \frac{q}{r^2} \hat{\mathbf{r}},
\]
where \(r\) denotes the distance from the point charge to the field point, vectorially, if the field point is located at \(\mathbf{l}\), and the source at \(\mathbf{l}'\), then \(\mathbf{r} = \mathbf{l} - \mathbf{l}'\). Notice that the above equation for the field yields a two-component equation in a two dimensional space. In such a case we have
\[
E_x = \frac{1}{4\pi \epsilon_0} \frac{q}{r^2} \frac{r_x}{r} = \frac{1}{4\pi \epsilon_0} \frac{q r_x}{r^3}
\]
and a similar expression is true for the \(y\) component of the electric field. The electric field abides by the superposition principle, that is, the field produced by \(n\) different source point charges at a single point \(P\) is exactly the vector sum of the individual electric fields due to the source charges. Taking all these facts into account, we can compute the electric field at arbitrarily many points embedded in a two-dimensional space.
</p>

<p>
Now that the concept has been clarified, we may proceed with the implementation of the algorithm to compute the electric field at some points on a plane. For simplicity we suppose \(1 / 4\pi \epsilon_0 = 1\).
</p>

<p>
The <code>electrostatic_field</code> routine takes two square numpy arrays, <code>_x</code> and <code>_y</code>, as an input; these arrays encode a grid of position vectors, viz., the \(x\) and \(y\) components of some number of evenly spaced points on a square region of the plane (the amount of points is defined by the user). Its output will be two numpy arrays, <code>E_x</code> and <code>E_y</code>, with the values of electrostatic field at each initially given point.
</p>

<p>
We only require one more input, which is the charge and the position of the sources; we may encode this information in a dictionary with charges as keys and tuples representing the positions of each source charge as items. We can read this information by defining a list <code>l</code>, whose elements are tuples containing every key on the original dictionary, associated with its respective item, i.e., tuples of the form <code>(key, item)</code>; recall that, in this case, each item is itself a tuple. To create this list we turn to the method <code>dict.items()</code>, and turn the resulting object into a list by applying the method <code>list()</code> on it. The rest of the process comes down to defining lists of the same length as <code>l</code>, which are then assigned its respective value in a while loop. We thus obtain three lists with the same length: <code>charges</code>, <code>source_x_positions_list</code>, and <code>source_y_positions_list</code>.
</p>

<p>
Now the computation of the electric field at every point encoded in the two initial arrays, <code>_x</code> and <code>_y</code>, can be easily carried out by abstraction using numpy arrays. We define two square arrays of the same order as <code>_x</code> and <code>_y</code>, namely <code>E_x</code> and <code>E_y</code>; these arrays have initially zero values, for we are then going to sum over all the electrostatic fields produced by the different charges, tying in with the superposition principle. We use a while loop to iterate through all the values in the list of charges, x positions, and y positions, which correspond to the sources and then proceed to compute the distance components as <code>delta_pos_x</code> and <code>delta_pos_y</code>, the magnitude of the distance as <code>R</code>, and the components of the electrostatic field as the sum of its current value with the value given by Coulomb&rsquo;s law for each charge in the list of charges.
</p>
<div class="org-src-container">
<pre class="src src-ipython">sources = {<span style="color: #bd93f9; font-weight: bold;">1</span>: (-<span style="color: #bd93f9; font-weight: bold;">1</span>,<span style="color: #bd93f9; font-weight: bold;">0</span>), <span style="color: #bd93f9; font-weight: bold;">1.1</span>: (<span style="color: #bd93f9; font-weight: bold;">1</span>,<span style="color: #bd93f9; font-weight: bold;">0</span>), -<span style="color: #bd93f9; font-weight: bold;">1</span>: (<span style="color: #bd93f9; font-weight: bold;">0</span>,<span style="color: #bd93f9; font-weight: bold;">1</span>), -<span style="color: #bd93f9; font-weight: bold;">1.1</span>: (<span style="color: #bd93f9; font-weight: bold;">0</span>,-<span style="color: #bd93f9; font-weight: bold;">1</span>)}

<span style="color: #ff79c6;">def</span> <span style="color: #50fa7b;">electrostatic_field</span>(_x, _y) :
    l = <span style="color: #ffb86c;">list</span>(sources.items())
    charges, source_x_positions_list, source_y_positions_list = [<span style="color: #bd93f9; font-weight: bold;">0</span>]*<span style="color: #ffb86c;">len</span>(l), [<span style="color: #bd93f9; font-weight: bold;">0</span>]*<span style="color: #ffb86c;">len</span>(l), [<span style="color: #bd93f9; font-weight: bold;">0</span>]*<span style="color: #ffb86c;">len</span>(l)

    i = <span style="color: #bd93f9; font-weight: bold;">0</span>
    <span style="color: #ff79c6;">while</span> i &lt; <span style="color: #ffb86c;">len</span>(l) :
        charges[i], (source_x_positions_list[i], source_y_positions_list[i]) = l[i]
        i += <span style="color: #bd93f9; font-weight: bold;">1</span>

    n, m = np.shape(_y) <span style="color: #6272a4;"># </span><span style="color: #6272a4;">n and m are the same number, for _y is a square matrix, as is _x</span>
    E_x, E_y = np.zeros((n,n)), np.zeros((n,n))

    i = <span style="color: #bd93f9; font-weight: bold;">0</span>
    <span style="color: #ff79c6;">while</span> i &lt; <span style="color: #ffb86c;">len</span>(charges) :
        delta_pos_x = _x - source_x_positions_list[i]
        delta_pos_y = _y - source_y_positions_list[i]
        R = np.sqrt(delta_pos_x**<span style="color: #bd93f9; font-weight: bold;">2</span> + delta_pos_y**<span style="color: #bd93f9; font-weight: bold;">2</span>)

        E_x += charges[i]*delta_pos_x/R**<span style="color: #bd93f9; font-weight: bold;">3</span>
        E_y += charges[i]*delta_pos_y/R**<span style="color: #bd93f9; font-weight: bold;">3</span>
        i += <span style="color: #bd93f9; font-weight: bold;">1</span>

    <span style="color: #ff79c6;">return</span> E_x, E_y
</pre>
</div>

<p>
The bulk of the <code>graph</code> routine is to create a two dimensional partition of the plane area defined by the user with the parameter <code>boxlength</code>. Actually, <code>boxlength</code> denotes half the length of the side of the figure, which is always going to be centred at (0,0); hence we must evenly partition an interval [-boxlength, boxlength]. Such a partition is given by <code>i*2*boxlength/(num_partitions-1) - boxlength</code> for i from 0 to the desired number of partitions. We must use the resulting set of numbers in a square matrix with <i>repeating rows</i>, which represents the x component of the position of a square, evenly spaced grid of points. The transpose of the aforementioned matrix is the y component of the same grid of points. These matrices are then used to compute the electrostatic field.
</p>

<p>
Now we only need to use the utilities of <code>matplotlib</code> to graph the electrostatic field of a configuration of source point charges.
</p>
<div class="org-src-container">
<pre class="src src-ipython">%config InlineBackend.figure_format = <span style="color: #f1fa8c;">'svg'</span>

<span style="color: #ff79c6;">def</span> <span style="color: #50fa7b;">graph</span>(boxlength, num_partitions) : <span style="color: #6272a4;"># </span><span style="color: #6272a4;">boxlength represents half the length of the side</span>
    x = [[i*<span style="color: #bd93f9; font-weight: bold;">2</span>*boxlength/(num_partitions-<span style="color: #bd93f9; font-weight: bold;">1</span>) - boxlength <span style="color: #ff79c6;">for</span> i <span style="color: #ff79c6;">in</span> <span style="color: #ffb86c;">range</span>(num_partitions)] <span style="color: #ff79c6;">for</span> k <span style="color: #ff79c6;">in</span> <span style="color: #ffb86c;">range</span>(num_partitions)]
    y = x[:]
    x, y = np.array(x), np.array(y).T
    E_x, E_y = electrostatic_field(x, y)

    plt.gca().set_aspect(<span style="color: #f1fa8c;">'equal'</span>, adjustable=<span style="color: #f1fa8c;">'box'</span>)
    plt.streamplot(x, y, E_x, E_y, color=<span style="color: #f1fa8c;">'k'</span>, arrowstyle =<span style="color: #f1fa8c;">'-&gt;'</span>)
    plt.xlabel(<span style="color: #f1fa8c;">'$x$'</span>)
    plt.ylabel(<span style="color: #f1fa8c;">'$y$'</span>)
    plt.show()

<span style="color: #6272a4;"># </span><span style="color: #6272a4;">execute the code</span>
graph(boxlength = <span style="color: #bd93f9; font-weight: bold;">2</span>,
      num_partitions = <span style="color: #bd93f9; font-weight: bold;">20</span>)
</pre>
</div>


<div id="orgd888d2b" class="figure">
<p><object type="image/svg+xml" data="./obipy-resources/M6Ah9e.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgf566842" class="outline-2">
<h2 id="orgf566842"><span class="section-number-2">2</span> Projectile motion</h2>
<div class="outline-text-2" id="text-2">
<p>
Our problem comes down to deciding whether the trajectory of a projectile intersects a line segment. Of course, we use the point particle simplification for the projectile.
</p>

<p>
In actuality, the only routines we need for our basic purposes are <code>get_horiz_position</code> and <code>score_check</code>, which are listed bellow. To begin with, <code>get_horiz_position</code> resorts to the kinematic equation
\[
y = y_0 + {v_y}_0 t - \frac12 gt^2
\]
which can be solved for \(t\) as
 \[
t = \frac{{v_y}_0 \pm \sqrt{{{v_y}_0}^2 - 2g(y - y_0)}}{g}
\]
We discard the negative branch of the square root, for it yields points on the ascending part of the trajectory. Basically, the above equation gives us the parameter \(t\) at which the projectile would reach the height of the basket, and then evaluates its horizontal position at such time. Note that there is a problem with the first part of the statement, for the trajectory does not necessarily reaches all heights; such a situation will yield a complex value for \(t\), and it shall also be interpreted as a failure in the condition. If the value of time is real, then we may proceed to evaluate whether or not the distance between the horizontal position and the centre of the line segment is between the radius of the latter.
</p>
<div class="org-src-container">
<pre class="src src-ipython">g = <span style="color: #bd93f9; font-weight: bold;">9.8</span>

<span style="color: #ff79c6;">def</span> <span style="color: #50fa7b;">get_horiz_position</span>(y_0, v_0, angle, y_ref) :
    <span style="color: #ff79c6;">try</span> :
        <span style="color: #ff79c6;">with</span> np.errstate(invalid=<span style="color: #f1fa8c;">'raise'</span>) :
            t = (v_0*np.sin(angle) + np.sqrt((v_0*np.sin(angle))**<span style="color: #bd93f9; font-weight: bold;">2</span> - <span style="color: #bd93f9; font-weight: bold;">2</span>*g*(y_ref - y_0))) / g
            _x = v_0*np.cos(angle)*t
            <span style="color: #ff79c6;">return</span> _x
    <span style="color: #ff79c6;">except</span> :
        _x = <span style="color: #f1fa8c;">'nan'</span>
        <span style="color: #ff79c6;">return</span> <span style="color: #8be9fd;">False</span>

<span style="color: #ff79c6;">def</span> <span style="color: #50fa7b;">score_check</span>(y_0, v_0, angle, x_basket, y_basket, radius) :
    _x = get_horiz_position(y_0, v_0, angle, y_basket)
    <span style="color: #ff79c6;">if</span> <span style="color: #ffb86c;">isinstance</span>(_x, <span style="color: #ffb86c;">float</span>) == <span style="color: #8be9fd;">True</span> :
        <span style="color: #ff79c6;">return</span> <span style="color: #ffb86c;">bool</span>(np.<span style="color: #ffb86c;">abs</span>(_x - x_basket) &lt; radius)
    <span style="color: #ff79c6;">else</span> :
        <span style="color: #ff79c6;">return</span> <span style="color: #8be9fd;">False</span>
</pre>
</div>

<p>
Now for visualisation purposes, we define the routine <code>get_vert_position</code> to calculate the vertical position of a set of points between 0 and the moment in which the horizontal position reaches the floor again. This allows us to graph the trajectory. This allows us to graph the trajectory.
</p>
<div class="org-src-container">
<pre class="src src-ipython">%config InlineBackend.figure_format = <span style="color: #f1fa8c;">'svg'</span>
<span style="color: #ff79c6;">def</span> <span style="color: #50fa7b;">get_vert_position</span>(y_0, v_0, angle, x_ref) :
    t = x_ref / (v_0*np.cos(angle))
    _y = y_0 + v_0*np.sin(angle)*t - <span style="color: #bd93f9; font-weight: bold;">0.5</span>*g*t**<span style="color: #bd93f9; font-weight: bold;">2</span>
    <span style="color: #ff79c6;">return</span> _y

<span style="color: #ff79c6;">def</span> <span style="color: #50fa7b;">plot</span>(y_0, v_0, angle, x_basket, y_basket, radius) :
    _x = np.linspace(<span style="color: #bd93f9; font-weight: bold;">0</span>, get_horiz_position(y_0, v_0, angle, <span style="color: #bd93f9; font-weight: bold;">0</span>), <span style="color: #bd93f9; font-weight: bold;">40</span>)
    _y = get_vert_position(y_0, v_0, angle, _x)

    <span style="color: #ff79c6;">if</span> score_check(y_0, v_0, angle, x_basket, y_basket, radius) == <span style="color: #8be9fd;">True</span> :
        plt.suptitle(<span style="color: #f1fa8c;">'It\'s a point!'</span>)
    <span style="color: #ff79c6;">else</span> :
        plt.suptitle(<span style="color: #f1fa8c;">'Bad luck!'</span>)

    plt.gca().set_aspect(<span style="color: #f1fa8c;">'equal'</span>, adjustable=<span style="color: #f1fa8c;">'box'</span>)
    plt.xlabel(<span style="color: #f1fa8c;">'$x$'</span>)
    plt.ylabel(<span style="color: #f1fa8c;">'$y$'</span>)
    plt.title(<span style="color: #f1fa8c;">'Trajectory'</span>)
    plt.grid(<span style="color: #8be9fd;">True</span>)
    plt.plot(_x,_y)
    plt.plot((x_basket - radius, x_basket + radius),(y_basket, y_basket))
    plt.show()

<span style="color: #6272a4;"># </span><span style="color: #6272a4;">Execute the code</span>
plot(y_0 = <span style="color: #bd93f9; font-weight: bold;">2</span>,
     v_0 = <span style="color: #bd93f9; font-weight: bold;">8</span>,
     angle = np.pi/<span style="color: #bd93f9; font-weight: bold;">3</span>,
     x_basket = <span style="color: #bd93f9; font-weight: bold;">4</span>,
     y_basket = <span style="color: #bd93f9; font-weight: bold;">4</span>,
     radius = <span style="color: #bd93f9; font-weight: bold;">0.23</span>)
</pre>
</div>


<div id="org120267c" class="figure">
<p><object type="image/svg+xml" data="./obipy-resources/ZG6YnE.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Juan David Salcedo Hernández</p>
<p class="date">Created: 2021-09-29 Wed 15:37</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.1 (<a href="https://orgmode.org">Org</a> mode 9.5)</p>
</div>
</body>
</html>
